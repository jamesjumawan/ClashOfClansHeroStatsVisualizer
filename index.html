<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clash of Clans Hero Upgrade Visualizer</title>
    <link rel="stylesheet" href="assets/css/hero_upgrade_visualizer.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>⚔️ Clash of Clans Hero Upgrade Visualizer ⚔️</h1>
            <p>Interactive analysis of percentage increases per level for all hero stats</p>
            
            <div class="hero-selector">
                <label for="heroSelect">Select a Hero:</label>
                <select id="heroSelect">
                    <option value="">Choose a hero...</option>
                </select>
            </div>

            <div class="view-selector">
                <label for="viewSelect">Chart View:</label>
                <select id="viewSelect">
                    <option value="percentage">Percentage Increase per Level (%)</option>
                    <option value="rawStats">Raw Stats per Level</option>
                    <option value="rawIncrease">Raw Stat Increase per Level</option>
                </select>
            </div>
        </div>

        <div id="loading" class="loading">
            <p>Loading hero data...</p>
        </div>

        <div id="error" class="error" style="display: none;">
            <h3>Error Loading Data</h3>
            <p>Unable to load hero statistics. Please check the data files and try again.</p>
        </div>

        <div id="content" style="display: none;">
            <!-- Hero sections will be dynamically generated here -->
        </div>
    </div>

    <!-- Load the browser-compatible logic file and display script -->
    <script src="assets/js/hero_upgrade_web_visualizer.js"></script>
    <script>
        // Enhanced display-specific logic for the HTML page
        class HeroUpgradeVisualizer {
            constructor() {
                this.charts = {};
                this.heroData = null;
                this.processedData = null;
                this.currentView = 'percentage'; // Track current view
            }

            async loadData() {
                try {
                    // Load actual hero data from JSON files
                    await this.loadHeroDataFromFiles();
                    this.renderContent();
                } catch (error) {
                    console.error('Error loading data:', error);
                    this.showError();
                }
            }

            async loadHeroDataFromFiles() {
                // Use the browser-compatible data loading function
                if (window.HeroUpgradeLogic) {
                    this.heroData = await window.HeroUpgradeLogic.loadHeroDataFromFiles();
                    
                    // Process the loaded data
                    if (Object.keys(this.heroData).length > 0) {
                        this.processedData = window.HeroUpgradeLogic.processAllHeroData(this.heroData);
                    } else {
                        throw new Error('No hero data loaded');
                    }
                } else {
                    throw new Error('HeroUpgradeLogic not available');
                }
            }

            renderContent() {
                const loadingElement = document.getElementById('loading');
                const contentElement = document.getElementById('content');
                
                loadingElement.style.display = 'none';
                contentElement.style.display = 'block';

                // Clear any existing content
                contentElement.innerHTML = '';

                // Populate the hero selector dropdown
                this.populateHeroSelector();

                // Generate hero sections with real data
                this.renderHeroSections();
                
                // Generate comparison section with real data
                this.renderComparisonSection();

                // Initialize charts after content is rendered
                setTimeout(() => this.initializeCharts(), 100);

                // Set up hero selector event listener
                this.setupHeroSelector();
            }

            populateHeroSelector() {
                const heroSelect = document.getElementById('heroSelect');
                
                // Clear existing options (except the first one)
                heroSelect.innerHTML = '<option value="">Choose a hero...</option>';
                
                // Add hero options
                Object.keys(this.processedData).forEach(heroName => {
                    const option = document.createElement('option');
                    option.value = heroName;
                    option.textContent = heroName;
                    heroSelect.appendChild(option);
                });
            }

            setupHeroSelector() {
                const heroSelect = document.getElementById('heroSelect');
                const viewSelect = document.getElementById('viewSelect');
                
                heroSelect.addEventListener('change', (event) => {
                    const selectedHero = event.target.value;
                    this.showSelectedHero(selectedHero);
                });

                // Add view selector event listener
                viewSelect.addEventListener('change', (event) => {
                    this.currentView = event.target.value;
                    this.updateChartsForCurrentView();
                    this.updateComparisonTableForCurrentView();
                });

                // Initially show no heroes (only comparison section)
                this.showSelectedHero('');
            }

            updateChartsForCurrentView() {
                // Update all chart titles first
                this.updateChartTitles();
                
                // Update summary stats for current view
                this.updateSummaryStatsForCurrentView();
                
                // Destroy existing charts
                Object.values(this.charts).forEach(chart => chart.destroy());
                this.charts = {};
                
                // Recreate charts with new view
                this.initializeCharts();
            }

            updateSummaryStatsForCurrentView() {
                // Update all summary stats blocks based on current view
                const summaryStatsBlocks = document.querySelectorAll('.summary-stats');
                
                summaryStatsBlocks.forEach(summaryBlock => {
                    const chartContainer = summaryBlock.closest('.chart-container');
                    if (chartContainer) {
                        const chartTitle = chartContainer.querySelector('.chart-title');
                        if (chartTitle) {
                            const heroName = chartTitle.getAttribute('data-hero');
                            const statName = chartTitle.getAttribute('data-stat');
                            
                            // Find the corresponding stats data
                            const statTypeMap = {
                                'Damage Per Second': 'damagePerSecond',
                                'Hitpoints': 'hitpoints', 
                                'Health Recovery': 'healthRecovery'
                            };
                            
                            const statType = statTypeMap[statName];
                            if (heroName && statType && this.processedData[heroName]) {
                                const statsData = this.processedData[heroName].stats[statType];
                                if (statsData) {
                                    summaryBlock.innerHTML = this.generateSummaryStatsHTML(statsData, statName);
                                }
                            }
                        }
                    }
                });
            }

            updateChartTitles() {
                // Update all chart titles based on current view
                const chartTitles = document.querySelectorAll('.chart-title[data-hero][data-stat]');
                
                chartTitles.forEach(titleElement => {
                    const heroName = titleElement.getAttribute('data-hero');
                    const statName = titleElement.getAttribute('data-stat');
                    
                    const viewTitles = {
                        'percentage': `${heroName} - ${statName} Percentage Increase`,
                        'rawStats': `${heroName} - ${statName} Raw Values`,
                        'rawIncrease': `${heroName} - ${statName} Raw Increase per Level`
                    };
                    
                    titleElement.textContent = viewTitles[this.currentView];
                });
            }

            updateComparisonTableForCurrentView() {
                const existingTable = document.querySelector('.comparison-table');
                if (existingTable) {
                    const newTable = this.createComparisonTable();
                    existingTable.parentNode.replaceChild(newTable, existingTable);
                }
            }

            showSelectedHero(selectedHero) {
                const heroSections = document.querySelectorAll('.hero-section');
                
                heroSections.forEach(section => {
                    const heroTitle = section.querySelector('.hero-title');
                    if (heroTitle) {
                        const heroName = heroTitle.textContent.trim();
                        
                        if (selectedHero === '' || heroName === selectedHero) {
                            section.style.display = selectedHero === '' ? 'none' : 'block';
                        } else {
                            section.style.display = 'none';
                        }
                    }
                });

                // Always show comparison section
                const comparisonSection = document.querySelector('.comparison-section');
                if (comparisonSection) {
                    comparisonSection.style.display = 'block';
                }
            }

            renderHeroSections() {
                const contentElement = document.getElementById('content');
                const statTypes = ['damagePerSecond', 'hitpoints', 'healthRecovery'];
                const statDisplayNames = ['Damage Per Second', 'Hitpoints', 'Health Recovery'];

                Object.keys(this.processedData).forEach(heroName => {
                    const heroSection = document.createElement('div');
                    heroSection.className = 'hero-section';
                    
                    const heroTitle = document.createElement('div');
                    heroTitle.className = 'hero-title';
                    heroTitle.textContent = heroName;
                    heroSection.appendChild(heroTitle);

                    const statGrid = document.createElement('div');
                    statGrid.className = 'stat-grid';

                    statTypes.forEach((statType, index) => {
                        const heroStats = this.processedData[heroName].stats[statType];
                        if (!heroStats) return;

                        const chartContainer = this.createChartContainer(
                            heroName, 
                            statType, 
                            statDisplayNames[index], 
                            heroStats
                        );
                        statGrid.appendChild(chartContainer);
                    });

                    heroSection.appendChild(statGrid);
                    contentElement.appendChild(heroSection);
                });
            }

            createChartContainer(heroName, statType, displayName, statsData) {
                const container = document.createElement('div');
                container.className = 'chart-container';

                const chartId = `chart_${heroName.replace(/\s+/g, '')}_${statType}`;
                
                // Dynamic title based on current view and including hero name
                const viewTitles = {
                    'percentage': `${heroName} - ${displayName} Percentage Increase`,
                    'rawStats': `${heroName} - ${displayName} Raw Values`,
                    'rawIncrease': `${heroName} - ${displayName} Raw Increase per Level`
                };
                
                container.innerHTML = `
                    <div class="chart-title" data-hero="${heroName}" data-stat="${displayName}">${viewTitles[this.currentView]}</div>
                    <div class="chart-wrapper">
                        <canvas id="${chartId}"></canvas>
                    </div>
                    <div class="summary-stats">
                        ${this.generateSummaryStatsHTML(statsData, displayName)}
                    </div>
                `;

                return container;
            }

            generateSummaryStatsHTML(statsData, displayName) {
                if (this.currentView === 'percentage') {
                    return `
                        <h4>📊 Summary Statistics</h4>
                        <div class="stat-item">
                            <span class="stat-label">Average Increase:</span>
                            <span class="stat-value">${statsData.summary.avg.toFixed(2)}%</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Highest Increase:</span>
                            <span class="stat-value">${statsData.summary.max.toFixed(2)}% (Level ${statsData.summary.maxLevel})</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Lowest Increase:</span>
                            <span class="stat-value">${statsData.summary.min.toFixed(2)}% (Level ${statsData.summary.minLevel})</span>
                        </div>
                        <div style="margin-top: 15px;">
                            <strong>🏆 Top 3 Increases:</strong>
                            ${statsData.topIncreases.map((inc, i) => `
                                <div class="stat-item">
                                    <span class="stat-label">${i + 1}. Level ${inc.level}:</span>
                                    <span class="stat-value">+${inc.value.toFixed(2)}% (${inc.previousValue} → ${inc.actualValue})</span>
                                </div>
                            `).join('')}
                        </div>
                    `;
                } else if (this.currentView === 'rawStats') {
                    const rawData = statsData.rawStatsData || this.calculateRawStatsData(statsData);
                    return `
                        <h4>📊 Raw Stats Summary</h4>
                        <div class="stat-item">
                            <span class="stat-label">Starting Value (Level 1):</span>
                            <span class="stat-value">${rawData.initial}</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Final Value (Max Level):</span>
                            <span class="stat-value">${rawData.final}</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Total Growth:</span>
                            <span class="stat-value">${rawData.totalGrowth}</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Average per Level:</span>
                            <span class="stat-value">${rawData.avgPerLevel}</span>
                        </div>
                    `;
                } else {
                    const increaseData = statsData.rawIncreaseData || this.calculateRawIncreaseData(statsData);
                    return `
                        <h4>📊 Raw Increase Summary</h4>
                        <div class="stat-item">
                            <span class="stat-label">Average Increase:</span>
                            <span class="stat-value">${increaseData.avg}</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Largest Increase:</span>
                            <span class="stat-value">${increaseData.max} (Level ${increaseData.maxLevel})</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Smallest Increase:</span>
                            <span class="stat-value">${increaseData.min} (Level ${increaseData.minLevel})</span>
                        </div>
                    `;
                }
            }

            calculateRawStatsData(statsData) {
                if (!statsData.upgradeData || statsData.upgradeData.length === 0) {
                    return { initial: 'N/A', final: 'N/A', totalGrowth: 'N/A', avgPerLevel: 'N/A' };
                }

                const initial = statsData.upgradeData[0].previousValue;
                const final = statsData.upgradeData[statsData.upgradeData.length - 1].actualValue;
                const totalGrowth = final - initial;
                const avgPerLevel = (totalGrowth / statsData.upgradeData.length).toFixed(1);

                return {
                    initial: initial.toLocaleString(),
                    final: final.toLocaleString(),
                    totalGrowth: totalGrowth.toLocaleString(),
                    avgPerLevel: avgPerLevel
                };
            }

            calculateRawIncreaseData(statsData) {
                if (!statsData.upgradeData || statsData.upgradeData.length === 0) {
                    return { avg: 'N/A', max: 'N/A', maxLevel: 'N/A', min: 'N/A', minLevel: 'N/A' };
                }

                const increases = statsData.upgradeData.map(upgrade => 
                    upgrade.actualValue - upgrade.previousValue
                );

                const avg = (increases.reduce((sum, inc) => sum + inc, 0) / increases.length).toFixed(1);
                const max = Math.max(...increases);
                const min = Math.min(...increases);
                const maxLevel = statsData.upgradeData[increases.indexOf(max)].level;
                const minLevel = statsData.upgradeData[increases.indexOf(min)].level;

                return {
                    avg: avg,
                    max: max.toLocaleString(),
                    min: min.toLocaleString(),
                    maxLevel: maxLevel,
                    minLevel: minLevel
                };
            }

            renderComparisonSection() {
                const contentElement = document.getElementById('content');
                const comparisonSection = document.createElement('div');
                comparisonSection.className = 'comparison-section';
                
                const title = document.createElement('div');
                title.className = 'comparison-title';
                title.textContent = '🔍 Cross-Hero Comparison';
                comparisonSection.appendChild(title);

                const table = this.createComparisonTable();
                comparisonSection.appendChild(table);

                contentElement.appendChild(comparisonSection);
            }

            createComparisonTable() {
                const table = document.createElement('table');
                table.className = 'comparison-table';

                // Create dynamic header based on current view
                const thead = document.createElement('thead');
                const headers = this.getComparisonTableHeaders();
                thead.innerHTML = `
                    <tr>
                        <th>Hero</th>
                        ${headers.map(header => `<th>${header}</th>`).join('')}
                    </tr>
                `;
                table.appendChild(thead);

                // Create body with comparison data
                const tbody = document.createElement('tbody');
                const comparisonData = this.generateComparisonTableData();
                
                comparisonData.rows.forEach(row => {
                    const tr = document.createElement('tr');
                    const cells = this.generateTableRowCells(row);
                    tr.innerHTML = `
                        <td><strong>${row.hero}</strong></td>
                        ${cells.join('')}
                    `;
                    tbody.appendChild(tr);
                });

                table.appendChild(tbody);
                return table;
            }

            getComparisonTableHeaders() {
                if (this.currentView === 'percentage') {
                    return ['DPS Avg %', 'DPS Max %', 'HP Avg %', 'HP Max %', 'Recovery Avg %', 'Recovery Max %'];
                } else if (this.currentView === 'rawStats') {
                    return ['DPS Start', 'DPS Final', 'HP Start', 'HP Final', 'Recovery Start', 'Recovery Final'];
                } else {
                    return ['DPS Avg Inc', 'DPS Max Inc', 'HP Avg Inc', 'HP Max Inc', 'Recovery Avg Inc', 'Recovery Max Inc'];
                }
            }

            generateTableRowCells(row) {
                if (this.currentView === 'percentage') {
                    return [
                        `<td class="${row.dpsAvgHighlight ? 'highlight-max' : row.dpsAvgLowlight ? 'highlight-min' : ''}">${row.dpsAvg}</td>`,
                        `<td class="${row.dpsMaxHighlight ? 'highlight-max' : row.dpsMaxLowlight ? 'highlight-min' : ''}">${row.dpsMax}</td>`,
                        `<td class="${row.hpAvgHighlight ? 'highlight-max' : row.hpAvgLowlight ? 'highlight-min' : ''}">${row.hpAvg}</td>`,
                        `<td class="${row.hpMaxHighlight ? 'highlight-max' : row.hpMaxLowlight ? 'highlight-min' : ''}">${row.hpMax}</td>`,
                        `<td class="${row.recoveryAvgHighlight ? 'highlight-max' : row.recoveryAvgLowlight ? 'highlight-min' : ''}">${row.recoveryAvg}</td>`,
                        `<td class="${row.recoveryMaxHighlight ? 'highlight-max' : row.recoveryMaxLowlight ? 'highlight-min' : ''}">${row.recoveryMax}</td>`
                    ];
                } else if (this.currentView === 'rawStats') {
                    return [
                        `<td class="${row.dpsStartHighlight ? 'highlight-max' : row.dpsStartLowlight ? 'highlight-min' : ''}">${row.dpsStart}</td>`,
                        `<td class="${row.dpsFinalHighlight ? 'highlight-max' : row.dpsFinalLowlight ? 'highlight-min' : ''}">${row.dpsFinal}</td>`,
                        `<td class="${row.hpStartHighlight ? 'highlight-max' : row.hpStartLowlight ? 'highlight-min' : ''}">${row.hpStart}</td>`,
                        `<td class="${row.hpFinalHighlight ? 'highlight-max' : row.hpFinalLowlight ? 'highlight-min' : ''}">${row.hpFinal}</td>`,
                        `<td class="${row.recoveryStartHighlight ? 'highlight-max' : row.recoveryStartLowlight ? 'highlight-min' : ''}">${row.recoveryStart}</td>`,
                        `<td class="${row.recoveryFinalHighlight ? 'highlight-max' : row.recoveryFinalLowlight ? 'highlight-min' : ''}">${row.recoveryFinal}</td>`
                    ];
                } else {
                    return [
                        `<td class="${row.dpsAvgIncHighlight ? 'highlight-max' : row.dpsAvgIncLowlight ? 'highlight-min' : ''}">${row.dpsAvgInc}</td>`,
                        `<td class="${row.dpsMaxIncHighlight ? 'highlight-max' : row.dpsMaxIncLowlight ? 'highlight-min' : ''}">${row.dpsMaxInc}</td>`,
                        `<td class="${row.hpAvgIncHighlight ? 'highlight-max' : row.hpAvgIncLowlight ? 'highlight-min' : ''}">${row.hpAvgInc}</td>`,
                        `<td class="${row.hpMaxIncHighlight ? 'highlight-max' : row.hpMaxIncLowlight ? 'highlight-min' : ''}">${row.hpMaxInc}</td>`,
                        `<td class="${row.recoveryAvgIncHighlight ? 'highlight-max' : row.recoveryAvgIncLowlight ? 'highlight-min' : ''}">${row.recoveryAvgInc}</td>`,
                        `<td class="${row.recoveryMaxIncHighlight ? 'highlight-max' : row.recoveryMaxIncLowlight ? 'highlight-min' : ''}">${row.recoveryMaxInc}</td>`
                    ];
                }
            }

            generateComparisonTableData() {
                const rows = [];
                const maxValues = {};
                const minValues = {}; // Add min values tracking

                // Calculate data and max/min values for highlighting based on current view
                const statTypes = ['damagePerSecond', 'hitpoints', 'healthRecovery'];
                
                if (this.currentView === 'percentage') {
                    // Calculate max and min values for percentage view
                    ['Avg', 'Max'].forEach(type => {
                        statTypes.forEach(stat => {
                            const key = `${stat}${type}`;
                            const values = Object.keys(this.processedData).map(hero => {
                                const heroStats = this.processedData[hero].stats[stat];
                                return heroStats ? heroStats.summary[type.toLowerCase()] : 0;
                            });
                            maxValues[key] = Math.max(...values);
                            minValues[key] = Math.min(...values);
                        });
                    });

                    // Generate percentage rows
                    Object.keys(this.processedData).forEach(heroName => {
                        const heroStats = this.processedData[heroName].stats;
                        
                        const dpsAvg = heroStats.damagePerSecond?.summary.avg || 0;
                        const dpsMax = heroStats.damagePerSecond?.summary.max || 0;
                        const hpAvg = heroStats.hitpoints?.summary.avg || 0;
                        const hpMax = heroStats.hitpoints?.summary.max || 0;
                        const recoveryAvg = heroStats.healthRecovery?.summary.avg || 0;
                        const recoveryMax = heroStats.healthRecovery?.summary.max || 0;

                        rows.push({
                            hero: heroName,
                            dpsAvg: dpsAvg.toFixed(2) + '%',
                            dpsMax: dpsMax.toFixed(2) + '%',
                            hpAvg: hpAvg.toFixed(2) + '%',
                            hpMax: hpMax.toFixed(2) + '%',
                            recoveryAvg: recoveryAvg.toFixed(2) + '%',
                            recoveryMax: recoveryMax.toFixed(2) + '%',
                            dpsAvgHighlight: dpsAvg === maxValues.damagePerSecondAvg,
                            dpsMaxHighlight: dpsMax === maxValues.damagePerSecondMax,
                            hpAvgHighlight: hpAvg === maxValues.hitpointsAvg,
                            hpMaxHighlight: hpMax === maxValues.hitpointsMax,
                            recoveryAvgHighlight: recoveryAvg === maxValues.healthRecoveryAvg,
                            recoveryMaxHighlight: recoveryMax === maxValues.healthRecoveryMax,
                            // Add min highlighting flags
                            dpsAvgLowlight: dpsAvg === minValues.damagePerSecondAvg,
                            dpsMaxLowlight: dpsMax === minValues.damagePerSecondMax,
                            hpAvgLowlight: hpAvg === minValues.hitpointsAvg,
                            hpMaxLowlight: hpMax === minValues.hitpointsMax,
                            recoveryAvgLowlight: recoveryAvg === minValues.healthRecoveryAvg,
                            recoveryMaxLowlight: recoveryMax === minValues.healthRecoveryMax
                        });
                    });
                } else if (this.currentView === 'rawStats') {
                    // Calculate max and min values for raw stats view
                    ['Start', 'Final'].forEach(type => {
                        statTypes.forEach(stat => {
                            const key = `${stat}${type}`;
                            const values = Object.keys(this.processedData).map(hero => {
                                const heroStats = this.processedData[hero].stats[stat];
                                if (!heroStats || !heroStats.upgradeData || heroStats.upgradeData.length === 0) return 0;
                                
                                if (type === 'Start') {
                                    return heroStats.upgradeData[0].previousValue;
                                } else {
                                    return heroStats.upgradeData[heroStats.upgradeData.length - 1].actualValue;
                                }
                            });
                            maxValues[key] = Math.max(...values);
                            minValues[key] = Math.min(...values);
                        });
                    });

                    // Generate raw stats rows
                    Object.keys(this.processedData).forEach(heroName => {
                        const heroStats = this.processedData[heroName].stats;
                        
                        const dpsStart = heroStats.damagePerSecond?.upgradeData?.[0]?.previousValue || 0;
                        const dpsFinal = heroStats.damagePerSecond?.upgradeData?.[heroStats.damagePerSecond.upgradeData.length - 1]?.actualValue || 0;
                        const hpStart = heroStats.hitpoints?.upgradeData?.[0]?.previousValue || 0;
                        const hpFinal = heroStats.hitpoints?.upgradeData?.[heroStats.hitpoints.upgradeData.length - 1]?.actualValue || 0;
                        const recoveryStart = heroStats.healthRecovery?.upgradeData?.[0]?.previousValue || 0;
                        const recoveryFinal = heroStats.healthRecovery?.upgradeData?.[heroStats.healthRecovery.upgradeData.length - 1]?.actualValue || 0;

                        rows.push({
                            hero: heroName,
                            dpsStart: dpsStart.toLocaleString(),
                            dpsFinal: dpsFinal.toLocaleString(),
                            hpStart: hpStart.toLocaleString(),
                            hpFinal: hpFinal.toLocaleString(),
                            recoveryStart: recoveryStart.toLocaleString(),
                            recoveryFinal: recoveryFinal.toLocaleString(),
                            dpsStartHighlight: dpsStart === maxValues.damagePerSecondStart,
                            dpsFinalHighlight: dpsFinal === maxValues.damagePerSecondFinal,
                            hpStartHighlight: hpStart === maxValues.hitpointsStart,
                            hpFinalHighlight: hpFinal === maxValues.hitpointsFinal,
                            recoveryStartHighlight: recoveryStart === maxValues.healthRecoveryStart,
                            recoveryFinalHighlight: recoveryFinal === maxValues.healthRecoveryFinal,
                            // Add min highlighting flags
                            dpsStartLowlight: dpsStart === minValues.damagePerSecondStart,
                            dpsFinalLowlight: dpsFinal === minValues.damagePerSecondFinal,
                            hpStartLowlight: hpStart === minValues.hitpointsStart,
                            hpFinalLowlight: hpFinal === minValues.hitpointsFinal,
                            recoveryStartLowlight: recoveryStart === minValues.healthRecoveryStart,
                            recoveryFinalLowlight: recoveryFinal === minValues.healthRecoveryFinal
                        });
                    });
                } else {
                    // Raw increase view
                    // Calculate max and min values for raw increase view
                    ['AvgInc', 'MaxInc'].forEach(type => {
                        statTypes.forEach(stat => {
                            const key = `${stat}${type}`;
                            const values = Object.keys(this.processedData).map(hero => {
                                const heroStats = this.processedData[hero].stats[stat];
                                if (!heroStats || !heroStats.upgradeData || heroStats.upgradeData.length === 0) return 0;
                                
                                const increases = heroStats.upgradeData.map(upgrade => 
                                    upgrade.actualValue - upgrade.previousValue
                                );
                                
                                if (type === 'AvgInc') {
                                    return increases.reduce((sum, inc) => sum + inc, 0) / increases.length;
                                } else {
                                    return Math.max(...increases);
                                }
                            });
                            maxValues[key] = Math.max(...values);
                            minValues[key] = Math.min(...values);
                        });
                    });

                    // Generate raw increase rows
                    Object.keys(this.processedData).forEach(heroName => {
                        const heroStats = this.processedData[heroName].stats;
                        
                        // Calculate DPS increases
                        const dpsIncreases = heroStats.damagePerSecond?.upgradeData?.map(u => u.actualValue - u.previousValue) || [];
                        const dpsAvgInc = dpsIncreases.length ? (dpsIncreases.reduce((s, i) => s + i, 0) / dpsIncreases.length) : 0;
                        const dpsMaxInc = dpsIncreases.length ? Math.max(...dpsIncreases) : 0;
                        
                        // Calculate HP increases
                        const hpIncreases = heroStats.hitpoints?.upgradeData?.map(u => u.actualValue - u.previousValue) || [];
                        const hpAvgInc = hpIncreases.length ? (hpIncreases.reduce((s, i) => s + i, 0) / hpIncreases.length) : 0;
                        const hpMaxInc = hpIncreases.length ? Math.max(...hpIncreases) : 0;
                        
                        // Calculate Recovery increases
                        const recoveryIncreases = heroStats.healthRecovery?.upgradeData?.map(u => u.actualValue - u.previousValue) || [];
                        const recoveryAvgInc = recoveryIncreases.length ? (recoveryIncreases.reduce((s, i) => s + i, 0) / recoveryIncreases.length) : 0;
                        const recoveryMaxInc = recoveryIncreases.length ? Math.max(...recoveryIncreases) : 0;

                        rows.push({
                            hero: heroName,
                            dpsAvgInc: dpsAvgInc.toFixed(1),
                            dpsMaxInc: dpsMaxInc.toLocaleString(),
                            hpAvgInc: hpAvgInc.toFixed(1),
                            hpMaxInc: hpMaxInc.toLocaleString(),
                            recoveryAvgInc: recoveryAvgInc.toFixed(1),
                            recoveryMaxInc: recoveryMaxInc.toLocaleString(),
                            dpsAvgIncHighlight: Math.abs(dpsAvgInc - maxValues.damagePerSecondAvgInc) < 0.1,
                            dpsMaxIncHighlight: dpsMaxInc === maxValues.damagePerSecondMaxInc,
                            hpAvgIncHighlight: Math.abs(hpAvgInc - maxValues.hitpointsAvgInc) < 0.1,
                            hpMaxIncHighlight: hpMaxInc === maxValues.hitpointsMaxInc,
                            recoveryAvgIncHighlight: Math.abs(recoveryAvgInc - maxValues.healthRecoveryAvgInc) < 0.1,
                            recoveryMaxIncHighlight: recoveryMaxInc === maxValues.healthRecoveryMaxInc,
                            // Add min highlighting flags
                            dpsAvgIncLowlight: Math.abs(dpsAvgInc - minValues.damagePerSecondAvgInc) < 0.1,
                            dpsMaxIncLowlight: dpsMaxInc === minValues.damagePerSecondMaxInc,
                            hpAvgIncLowlight: Math.abs(hpAvgInc - minValues.hitpointsAvgInc) < 0.1,
                            hpMaxIncLowlight: hpMaxInc === minValues.hitpointsMaxInc,
                            recoveryAvgIncLowlight: Math.abs(recoveryAvgInc - minValues.healthRecoveryAvgInc) < 0.1,
                            recoveryMaxIncLowlight: recoveryMaxInc === minValues.healthRecoveryMaxInc
                        });
                    });
                }

                return { rows, maxValues, minValues };
            }

            initializeCharts() {
                Object.keys(this.processedData).forEach(heroName => {
                    const statTypes = ['damagePerSecond', 'hitpoints', 'healthRecovery'];
                    
                    statTypes.forEach(statType => {
                        const heroStats = this.processedData[heroName].stats[statType];
                        if (!heroStats) return;

                        const chartId = `chart_${heroName.replace(/\s+/g, '')}_${statType}`;
                        const canvas = document.getElementById(chartId);
                        
                        if (canvas) {
                            this.createChart(canvas, heroStats.chartData, heroStats.upgradeData);
                        }
                    });
                });
            }

            createChart(canvas, chartData, upgradeData) {
                const ctx = canvas.getContext('2d');
                
                // Generate chart data based on current view
                const viewChartData = this.generateChartDataForView(chartData, upgradeData);
                
                const chart = new Chart(ctx, {
                    type: 'line',
                    data: viewChartData,
                    options: this.getChartOptionsForView(upgradeData)
                });

                this.charts[canvas.id] = chart;
            }

            generateChartDataForView(originalChartData, upgradeData) {
                if (this.currentView === 'percentage') {
                    return originalChartData;
                } else if (this.currentView === 'rawStats') {
                    // Generate raw stats chart data
                    const labels = upgradeData.map(upgrade => `Level ${upgrade.level}`);
                    const data = upgradeData.map(upgrade => upgrade.actualValue);
                    
                    return {
                        labels: labels,
                        datasets: [{
                            label: 'Raw Stat Values',
                            data: data,
                            borderColor: '#2ecc71',
                            backgroundColor: 'rgba(46, 204, 113, 0.1)',
                            borderWidth: 3,
                            fill: true,
                            tension: 0
                        }]
                    };
                } else {
                    // Generate raw increase chart data
                    const labels = upgradeData.map(upgrade => `Level ${upgrade.level}`);
                    const data = upgradeData.map(upgrade => upgrade.actualValue - upgrade.previousValue);
                    
                    return {
                        labels: labels,
                        datasets: [{
                            label: 'Raw Stat Increase',
                            data: data,
                            borderColor: '#e74c3c',
                            backgroundColor: 'rgba(231, 76, 60, 0.1)',
                            borderWidth: 3,
                            fill: true,
                            tension: 0
                        }]
                    };
                }
            }

            getChartOptionsForView(upgradeData) {
                const yAxisTitles = {
                    'percentage': 'Percentage Increase (%)',
                    'rawStats': 'Raw Stat Value',
                    'rawIncrease': 'Raw Stat Increase'
                };

                return {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: this.currentView !== 'rawStats',
                            title: {
                                display: true,
                                text: yAxisTitles[this.currentView]
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Hero Level'
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                afterLabel: (context) => {
                                    const dataIndex = context.dataIndex;
                                    const data = upgradeData[dataIndex];
                                    
                                    if (data) {
                                        if (this.currentView === 'percentage') {
                                            return [
                                                `Previous Value: ${data.previousValue}`,
                                                `New Value: ${data.actualValue}`,
                                                `Increase: +${data.value.toFixed(2)}%`
                                            ];
                                        } else if (this.currentView === 'rawStats') {
                                            return [
                                                `Previous Level Value: ${data.previousValue}`,
                                                `Raw Increase: +${data.actualValue - data.previousValue}`
                                            ];
                                        } else {
                                            return [
                                                `Previous Value: ${data.previousValue}`,
                                                `New Value: ${data.actualValue}`,
                                                `Raw Increase: +${data.actualValue - data.previousValue}`
                                            ];
                                        }
                                    }
                                    return [];
                                }
                            }
                        },
                        legend: {
                            display: false
                        }
                    }
                };
            }

            showError() {
                const loadingElement = document.getElementById('loading');
                const errorElement = document.getElementById('error');
                
                loadingElement.style.display = 'none';
                errorElement.style.display = 'block';
            }
        }

        // Initialize the visualizer when the page loads
        document.addEventListener('DOMContentLoaded', function() {
            const visualizer = new HeroUpgradeVisualizer();
            visualizer.loadData();
        });
    </script>
</body>
</html>